//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Untitled
//  @ File Name : LogN_ClassAb_CrePorNom.java
//  @ Date : 06/05/2010
//  @ Author : 
//
//



package Logica_Negocio.Dominio.CPorNom;


import Logica_Negocio.LogN_Inter_Duplicado;
import Logica_Negocio.LogN_Inter_Igualdades;
import Logica_Negocio.LogN_Inter_Validar;
import Logica_Negocio.MiExepcion.InputException;
import java.util.Observable;


/**
 * Clase que se crea identificable por su nombre y un numero de identificable
 * @author ary
 */
public  abstract class LogN_ClassAb_CrePorNom extends Observable implements 
        LogN_Inter_Igualdades<LogN_ClassAb_CrePorNom>, 
        LogN_Inter_Validar,
        LogN_Inter_Duplicado<LogN_ClassAb_CrePorNom> {


    //Atributos ===============================================================
    /**
     * Nombre que lo identifica
    **/
    protected String mNom;

    private int mNum = -1;


    /**
     *
     * <b><font color="blue">Tipo de LogN_Class_CreadoXNom</b></font> <br>
     * Representa el tipo de LogN_Class_CreadoXNom es decir el nombre de los conceptos que enredan de esta clase
     */
    public final String Tipo;

    // Constructores ===========================================================

    public LogN_ClassAb_CrePorNom (String Tipo){
        this.Tipo = Tipo;
    }

    /**
     * Constructor que revise el nombre y asigna 0 predefinida mente
     * @param mNom Nombre
     */

    public LogN_ClassAb_CrePorNom(String mNom, String Tipo) {
        this(Tipo);
        this.mNom = mNom;

    }

    //metodos ==================================================================

    /**
     * Si el nombre o el numero son iguales
     *
     * @param    xObjCreXNom  bjeto a comparar
     *
     * return   True si el objeto pasado por par�metro es igual a este
    **/
    @Override
    public boolean equals(Object obj) {
        if (obj == this) return true;

        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final LogN_ClassAb_CrePorNom other = (LogN_ClassAb_CrePorNom) obj;
        
        if(mNum != -1 && other.getNum() == this.getNum()){
            return true;
        }
        
        if ((this.mNom == null) ? (other.mNom != null) : !this.mNom.equals(other.mNom)) {
            return false;
        }

        return true;
    }

    @Override
    public int hashCode() {
        int hash = 5;
        hash = 59 * hash + (this.mNom != null ? this.mNom.hashCode() : 0);
        return hash;
    }



    /**
     * Retorna el nombre
    **/
    public String getNom() {
        return mNom;
    }

    /**
     * Remplaza el nombres por el pasado por par�metro.
     *
     * @param    mNom  Nueva nombre.
     *
     * return   Retorna true  si el string pasada por par�metro no es una cadena vac�a, null, o solo contiene espacio en blanco.
    **/
    public abstract boolean setNom(String mNom);

    /**
     * Modifica este objeto con los datos del objeto pasado por par�metro
     *
     * @param    xObjCreXNom
    **/
    public  void  modificar(LogN_ClassAb_CrePorNom xObjCreXNom)throws InputException{
        xObjCreXNom.validar();
        this.mNom = xObjCreXNom.mNom;
    }

    public void validar ()throws InputException{
        String Error = "";
        if (!setNom(mNom))throw new InputException ("El nombre no es valido");


    }



    public int getNum (){
        return mNum;
    }

    public void setNum (int xNum){
        this.mNum = xNum;
    }

    @Override
    public String toString() {
        return mNom;
    }

    @Override
    public boolean duplicado(LogN_ClassAb_CrePorNom xObjCop) {
        if (this.getClass() != xObjCop.getClass()) return false;
        return mNom.equals(xObjCop);
    }






}