package Logica_Negocio;
//
//



import Logica_Negocio.Dominio.Dom_Class_IVA;
import Logica_Negocio.Dominio.Dom_Class_Moneda;
import Logica_Negocio.MiExepcion.InputException;
import Precentacion.LogN_Class_Accion;
import Utilidades.Util_Class_Utilitario;
import java.util.ArrayList;
import java.util.Date;
import java.util.Observable;
import java.util.Observer;
import java.util.logging.Level;
import java.util.logging.Logger;

//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Untitled
//  @ File Name : LogN_ClassAb_Factura.java
//  @ Date : 06/05/2010
//  @ Author : 
//
//




/**
 * <B><FONT COLOR="red">Factura Generica</FONT></B> <BR> Clase abstracta que posee
 * todo el comporta miento común de las facturas de sistema
 * @author Ary Gimenez
 * @version 1.0
 * @updated 09-nov-2011 06:57:05 p.m.
 */
public abstract class LogN_ClassAb_Factura extends Observable implements LogN_Inter_Validar, Observer, LogN_Inter_DocCon {
    //Atributos_________________________________________________________________
    /**
     * Linea de Factrua
     */
    private ArrayList<LogN_ClassAb_LineaFac> mColLinF = new ArrayList<LogN_ClassAb_LineaFac>();
    
    

    /**
     * Fecha de emisión de la factura
    **/
    private Date mFech = new Date();


    /**
     * Numero de la factura
    **/
    private int mNum;
    
    /**
     * Serie de la factura
     */
    private char mSerFac;

    /**
     * Porcentaje 1 de la factura obtenido de las l�neas de la factura
    **/
    private float mIva1;

    /**
     * Porcentaje 2 de las facturas obtenido de las l�neas de la factura
     * siempre y cuando sea diferente del "mIva2"
    **/
    private float mIva2;

    /**
     * Suma de los resultados de los IVA de l�neas de facturaci�n, teniendo
     * en cuanta que estas l�neas deben coincidir su porcentaje de IVA con
     * el �IVA1�
    **/
    private float mResIva1 = 0;

    /**
     * Suma de los resultados de los IVA de l�neas de facturacion, teniendo
     * en cuanta que estas l�neas deben coincidir su porcentaje de IVA con el
     * �IVA2�
    **/
    private float mResIva2 = 0;



    /**
     * Valor de la moneda que se va a utilizar en esta facturación
     */
    protected  LogN_Class_ValorMoneda mObjValMon = new  LogN_Class_ValorMoneda(0,  LogN_Class_Fachada.getInstancia().getMonedaLoc());

    /**
     * Lo que falta pagar de la factura lo cual se calcula con respecto al
     * monto de la forma de pago y al total final de la factura (getTotFin).
    **/
    private float mResPag = 0;



    /**
     * Colecci�n de forma de pago de la factura
    **/
    private ArrayList <LogN_Inter_FormaPag> mColForPag = new ArrayList<LogN_Inter_FormaPag>();;

    /**
     * Persona imbolucrada e la facturacion
     */
    protected  LogN_ClassAb_Persona mObjPer;

    //Constructor_______________________________________________________________________
    /**
     *<B>Este constructor inicializa el objeto (Factura) con sus valores por defecto </B>
     */

    public LogN_ClassAb_Factura(){

    }
    /**
     * <B>  Este constructor inicializa el objeto (Factura) con un numero el cual la identifica </B>
     * @param mNum Numero por el cual se va a identificar la factura
     * @param mSerie Serie de la factura A→Z 
     */
    public LogN_ClassAb_Factura(int mNum, char mSerie){
        this.mNum = mNum;
        this.mSerFac = mSerie;
    }
    /**
     * <B> <FONT COLOR="#E1EAF7">Constructor que abarca todos los datos de inicialización</FONT></B>
     * @param mColLinF Colección de lineas de factura
     * @param mFech Fecha de facturación
     * @param mNum Numero por el cual se va a identificar la factura
     * @param mSerFac Serie de la factura que junto al numero identifica a la factura (Ba de A→Z)
     * @param mColForPag Colección de forma de pago (esto comprende tonto de que forma se pago como de cuantas formas se pago)
     * @param mObjPer Persona a que pertenece esta factura (Puede ser Cliente o Proveedor, dependiendo el tipo de factura)
     * @param xObjMon Moneda de la factura
     * @throws InputException Excepcional lanzada por el método <I>setmColLinF()</I>
     */
    public LogN_ClassAb_Factura(ArrayList<LogN_ClassAb_LineaFac> mColLinF, Date mFech, int mNum,char mSerFac,  ArrayList<LogN_Inter_FormaPag> mColForPag, LogN_ClassAb_Persona mObjPer, Dom_Class_Moneda xObjMon) throws InputException {
         
        this.mFech = mFech;
        this.mNum = mNum;
        this.mColForPag = mColForPag;
        this.mObjPer = mObjPer;
        this.mSerFac = mSerFac;
        mObjValMon = new LogN_Class_ValorMoneda(0, xObjMon);
        this.setmColLinF(mColLinF);
    }
    /**
     * <B>Constructor que abarca todos los datos de inicialización recepto la colección de forma de pago</B><BR>
     * Es decir crea una factura  la cual no se a determinado la forma como se va a pagar
     * @param mColLinF Colección de lineas de factura
     * @param mFech Fecha de facturación
     * @param mNum Numero por el cual se va a identificar la factura
     * @param mSerFac Serie de la factura que junto al numero identifica a la factura (Ba de A→Z)
     * @param mObjPer Persona a que pertenece esta factura (Puede ser Cliente o Proveedor, dependiendo el tipo de factura)
     * @param xObjMon Moneda de la factura
     * @throws InputException Excepcional lanzada por el método <I>setmColLinF()</I>
     */
    public LogN_ClassAb_Factura(ArrayList<LogN_ClassAb_LineaFac> mColLinF, Date mFech, int mNum, char mSerFac,LogN_ClassAb_Persona mObjPer, Dom_Class_Moneda xObjMon) throws InputException {
        this(mColLinF, mFech, mNum,mSerFac, new ArrayList<LogN_Inter_FormaPag>(),mObjPer,xObjMon);
    }


    //Operaciones _____________________________________________________________________


    /**
     *<B>Retorna lo que falta pagar de la factura</B>
     * @return Resto a pagar 
     */
    public float getmResPag() {
        return Util_Class_Utilitario.Redondear_Sifras(2,mResPag);
                    
    }

    /**
     * Colección por la cual se va a remplazar
     * @return mColForPag Colección contenedora de forma de pago
     */
    public ArrayList<LogN_Inter_FormaPag> getmColForPag() {
        return new ArrayList<LogN_Inter_FormaPag> (mColForPag);
    }

    /**
     * Remplaza la colección de forma de pago por la pasada por parámetro
     * @param mColForPag Colección por la cual se va a remplazar
     */
    public void setmColForPag(ArrayList<LogN_Inter_FormaPag> mColForPag) {
        this.mColForPag = mColForPag;
    }

    /**
     * Retorna las líneas de la factura involucrada;
     * @return mColLinF ArrayList contenedora de las líneas de la factura
     */
    public ArrayList<LogN_ClassAb_LineaFac> getmColLinF() {
        return new ArrayList<LogN_ClassAb_LineaFac>(mColLinF);
    }


    /**
     * <B>Remplaza la colección de líneas de factura por la pasada por parámetro </B>
     * recalculando el subtotal, total e IVA de la factura, con respecto a las nuevas líneas de factura
     *
     * @param mColLinF Colección por la cual se va a remplazar
     * @throws InputException Excepcional no utilizada
     */
    public void setmColLinF(ArrayList<LogN_ClassAb_LineaFac> mColLinF) throws InputException {
        this.limpiarLinFac();
        for (LogN_ClassAb_LineaFac xObjLF: mColLinF)this.altaLineaFact(xObjLF);

    }

    /**
     * <B>Elimina todas las lintes de la factura</B>
     */
    private void limpiarLinFac(){
        boolean Salir = false;
        while (Salir == false){
            try{
               this.bajaLineaFach(mColLinF.get(0));
            }catch (IndexOutOfBoundsException ex){
                Salir = true;
            }
            
        }
    }

    /**
     * Retorna la fecha de la factura
     * @return fecha facturación
     */
    public Date getFech() {
        return mFech;

    }

    /**
     * Remplaza la fecha de la factura por la pasada por par�metro
     *
     * @param    mFech  Fecha por la cual se va a remplazar
     *
     * @return  Determina si se pudo efectuar la operaci�n
    **/
    public boolean setFech (Date mFech) {
        if (mFech == null) return false;
       this.mFech = mFech;
       return true;
    }
    
    @Override
    public Dom_Class_Moneda getMoneda (){
        return mObjValMon.getObjMon();
    }

    /**
     * Comprueba que el String pasado por parámetro no se una cadena null,
     * una cadena solo cantidad caracteres en blanco
     * @param s String a Comprobar
     * @return Retorna true si la cadena cumple las características
     * solicitadas, retorna false en caso contrario.
     */
    private boolean validarString (String s){
        if (s == null) return false;//compara q el objeto haga referencia a una bariable
        s = s.trim();// elimina los caracteres en balanco a los costados
        if (s.equals("")) return false;// es una cadena q no contiene valor
        return true;
    }
	
    /**
     * Retorna el numero  que identifica la factura
     *
     *@return    mNum
    **/
    public int getNum() {
        return mNum;
    }

    /**
     * Remplaza el n�mero de la factura siempre y cuando este no sea un valor negativo 
     * @param    mNum  Numero por el cual se va a remplazar
     * @return   Determina si se pudo efectuar la operaci�n
    **/
    public boolean setNum(int mNum) {
        if (mNum < 0)return false;
        this.mNum = mNum;
        return true;
            }

    /**
     * Retorna el IVA 1 de la factura 
     * @return   mIva1
    **/
    public float getIva1() {

        return Util_Class_Utilitario.Redondear_Sifras(2, mIva1);
    }

    @Override
    public Dom_Class_IVA getIVA() {
        try {
            return LogN_Class_Fachada.getInstancia().getIVA(mIva1);
        } catch (InputException ex) {
            
        }
        return null;
    }
    
    
    



    /**
     * Retorna el IVA 2 de la factura  
     * @return   mIva2
    **/
    public float getIva2() {

        return Util_Class_Utilitario.Redondear_Sifras(2, mIva2);

    }



    /**
     * Retorna el resultado de los IVA de las leneas de la factura
     * (la suma de los resultado del IVA de que correspondan con el IVA1 es
     * decir que el porcentaje del IVA de las l�neas sea igual al IVA de la
     * l�nea)
     *
     * @return   mResIva1 Resultado del IVA1
    **/
    public float getResIva1() {

    return Util_Class_Utilitario.Redondear_Sifras(2, mResIva1);
    }



    /**
     * Retorna el resultado de los IVA de las leneas de la factura (la suma 
     * de los resultado del IVA de que correspondan con el IVA2 es decir que
     * el porcentaje del IVA de las l�neas sea igual al IVA de la l�nea)
     *
     * @return   mResIva2 Resultado del IVA2
    **/
    public float getResIva2() {
        return Util_Class_Utilitario.Redondear_Sifras(2,mResIva2);

    }



    /**
     * Retorna el subtotal de la factura comprendido por la suma de los
     * subtotales sin impuesto de las l�neas.
     *
     * @return   mSubTot
    **/
    public float getSubTot() {
        return Util_Class_Utilitario.Redondear_Sifras(2,  mObjValMon.getMonto());
    }

    /**
     * Remplaza el subtotal de la factura si el valor pasado por par�metro 
     * es negativo vuelve al valor por defecto o sea al valor obtenido de la
     * suma de las l�neas de esta factura
     *
     * @param    mSubTot
     *
     * return   Determina si se pudo efectuar la operaci�n
    **/
    private void setSubTot(float mSubTot)  {
        this.mObjValMon.setMonto(mSubTot);
    }

    /**
     *  Retorna la persona involucrada en la factura
     * @return Persona involucrada en la factura
    **/
    public abstract LogN_ClassAb_Persona getPersona();

    /**
     * Remplaza la persona involucrada en la factura siguiendo las
     * restricciones de la clase  que lo implementa
     *
     * @param    mObjPer
     *
     * @throws InputException Especificada en las facturas que lo implanten
    **/
    public abstract void  setPersona(LogN_ClassAb_Persona mObjPer)throws  InputException;

    /**
     * <B>Retorna la serie de la factura </B>
     * @return mSerFec
     */
    public char getmSerFac() {
        return mSerFac;
    }
    /**
     * Remplaza la serie de la factura por la pasada por parametro  
     * @param mSerFac 
     */
    public void setmSerFac(char mSerFac) {
        this.mSerFac = mSerFac;
    }



    /**
     * Retorna el total Final de la factura incluyendo los impuestos.
     * @return Total final
    **/
    public float getTotFin() {

        return Util_Class_Utilitario.Redondear_Sifras(2, this.mObjValMon.getMonto() + mResIva1 + mResIva2);
    }
    
    

    @Override
    public float getMonto() {
        return getTotFin();
    }

    /**
     * Agrega una forma de pago para esta factura teniendo en cuenta que
     * esta no debe sobrepasar el monto r�state a pagar (mResPag).
     *
     * @param    xObjFomPag Forma de pago
     * 
     * @throws InputException Esta se lanza si la forma de pago:<UL>
         * <LI>No cumple los requerimiento de validación (meto validar())
         * <LI>Ya existe en la factura (según el mentado exequial)
         * <LI>El monto de esta supera el resto a pagar
     * </UL>
    **/
    public void altaForDePago(LogN_Inter_FormaPag xObjFomPag)throws InputException{
        if(xObjFomPag == null) throw new InputException("Forma de pago no valida");
        xObjFomPag.validar();
        for (int i = 0; i < mColForPag.size(); i++){
            LogN_Inter_FormaPag ObjForP = mColForPag.get(i);
            if (ObjForP.getTipo().equals(xObjFomPag.getTipo())){
                this.bajaForDePago(xObjFomPag);
            }
        }
        if (xObjFomPag.getMonto() > this.mResPag)throw new InputException("El monto de la forma de pago supera el monto de la factura  ");
        mColForPag.add(xObjFomPag);
        
        mResPag -= xObjFomPag.getMonto();

    }

    /**
     * Da de baja la forma de pago en la factura y resta el monto de la misma al Monto restante a pagar de la factura  
     *
     * @param    xObjFormPag forma de pago a dar de baja
     * @throws InputException Se lanza si la forma de pago no se puede dar de baja
    **/
    public void bajaForDePago(LogN_Inter_FormaPag xObjFormPag) throws InputException{
        if (mColForPag.remove(xObjFormPag)){
            this.mResPag += xObjFormPag.getMonto();
            return;
        }
        throw  new InputException("La forma de pago no existe en esta factura");

    }

    /**
     * <B>Da de alta las lineas de la factura actualisando los valores del iva y subtotal</B>
     *
     * @param   xObjLF Linea de factura a dar de alta
     *
     * @throws InputException Se lanza si la linea de factura:
     * <UL>
         * <LI>No cumple con las condiciones de validación (Método validar())
         * <LI>Ya existe en esta fatua (según el método xObjLF.equals())
     * <UL>
     **/
    public void altaLineaFact(LogN_ClassAb_LineaFac xObjLF) throws InputException {

        xObjLF.validar();
        //Retorna la factura que conisida con la pasada por parametro
        LogN_ClassAb_LineaFac ObjLF = getLineaFac(xObjLF); 
        // si es el mismo objeto retora  un error
        if (xObjLF == ObjLF) throw new InputException ("La línea ya existe en esta factura");
        
        //si la factura optenida es null quiere decir que la factura pasada por parametro no existe
        // y po lo tanto la da de alta 
        if (ObjLF == null){
            mColLinF.add(xObjLF);
            this.recalcular();
            
            xObjLF.addObserver(this);
            Notificar(new LogN_Class_Accion<LogN_ClassAb_LineaFac> (LogN_Class_Accion.Agreger, xObjLF));
        } else{ // en caso contrario actualisa los datos de la factura con la pasada por parametro
            ObjLF.setPrePro(xObjLF.getmPrePro());
            ObjLF.setDes(xObjLF.getmDes());
            ObjLF.setCan(ObjLF.getmCan()+xObjLF.getmCan());
            Notificar(this);
        }




    }
    /**
     * <B>Retorna la linea de factura en que consia (en el metodo equals())</B> con xObjLFac en esta factura 
     *
     * @param    xObjLFac Linea de factura para comparar
     *
     * @return  Retorna la linea de factura que cosida con xObjLFac o null en caso contrario
    **/

    public LogN_ClassAb_LineaFac getLineaFac (LogN_ClassAb_LineaFac xObjLFac){
        int Pos = mColLinF.indexOf(xObjLFac);
        if (Pos == -1) return null;
        return mColLinF.get(Pos);
    }



    /**
     * <B>Da de baja la línea de factura</B> pasada por parámetro  
     * @param xObjLF Línea de factura a dar de baja   
     * @return Retorna true o false dependiendo si se puedo o no realizar la operacion
     */
    public boolean bajaLineaFach(LogN_ClassAb_LineaFac xObjLF) {

        LogN_ClassAb_LineaFac ObjLF = getLineaFac(xObjLF);

        if (ObjLF == null) return false;

        mColLinF.remove(ObjLF);

        if (ObjLF.getmIva()== this.mIva1){
            mResIva1 -= ObjLF.getResIva();

        }else if(ObjLF.getmIva() == this.mIva2){
            mResIva2 -= ObjLF.getResIva();

        }// fin If
        // Suma y asigna el la suma del subtotal acual y la de la linea pasada
        // por parametro
        this.setSubTot(mObjValMon.mMonto - xObjLF.getSubTotSinIva());
        ObjLF.deleteObserver(this);
        Notificar(new LogN_Class_Accion<LogN_ClassAb_LineaFac> (LogN_Class_Accion.Eliminar, xObjLF));
        return true;

    }
    
    

    /**
     * Actualiza el stock de los articulo involucrados en esta facturaci�n
     * @throws InputException Se implementa en las Factura que lo implementas
    **/
    public abstract void actualizarStock()throws InputException;

    /**
     * Retorna un factura igual a la que ejecuta este método
     * @return Copia de factura
     */
    public abstract LogN_ClassAb_Factura duplicar();

    /**
     * Método para notificar a los observa dores de esta clase
     * 
     * @param arg
     */
    public void Notificar(Object arg){
        setChanged();
        notifyObservers(arg);
    }

    /**
     * SI Observable es es una linea de factura de esta factura llama al método "recalcular()"
     * @param o Observadoe por esta factura
     * @param arg
     */
    @Override
    public void update(Observable o, Object arg) {
        if (mColLinF.contains(o)){
            recalcular();
            Notificar(arg);
        }
    }

    /**
     * <B>Recalcula los totales de la factura </B> <BR>
     *  <UL>
         * <LI>Total IVA 2
         * <LI>Total IVA 1
         * <LI> Subtotal
         * <LI> Descuento
     * <UL>
     */
    private void recalcular (){

        mResIva1 = 0;
        mResIva2 = 0;
        float xSubTotal = 0;

        for (LogN_ClassAb_LineaFac xObjLF : mColLinF){
                    // Pregunta si el IVA de esta linea coinside con el IVA1 o el iva uno aun no se le a asignado valor
            if (xObjLF.getmIva()== this.mIva1 || mIva1 == 0){
                mResIva1 += xObjLF.getResIva();
                this.mIva1= xObjLF.getmIva();
            }else if(xObjLF.getmIva() == this.mIva2 || mIva2 ==0){
                mResIva2 += xObjLF.getResIva();
                this.mIva2= xObjLF.getmIva();
            }// fin If
            // Suma y asigna el la suma del subtotal acual y la de la linea pasada
            // por parametro
            
            xSubTotal +=  xObjLF.getSubTotSinIva();

        }
        
        this.setSubTot(xSubTotal);
       
        this.mResPag = getTotFin() - this.getMontoPago();
        

    }



    /**
     * <B>Comprueba la veracidad de los datos</B>
     * @throws InputException 
     * Compreuba que:
     * <UL> 
         * <LI>El resto a pagar sea 0 (que el total de la factura se haya dividido en las formas de pago) →  Falta pagar parte  de la factura←
         * <LI>Que la factura posea Líneas de facturación →La factura no posee líneas←
         * <LI>Que posea una fecha →La factura no posee fecha←
     * </UL>
     */
    @Override
    public void validar() throws InputException {
        
        
        if (mResPag > 0) throw new InputException("Falta pagar parte  de la factura");
        if (mColLinF.isEmpty()) throw new InputException("La factura no posee líneas");
        if (mFech == null) throw new InputException("La factura no posee fecha");
        
    }


    /**
     * <B>Crea una Linea de factura </B> pasándole los datos de inicializaron
     * @param mCan Cantidad de productos
     * @param mDes Porcentaje descuento producto
     * @param mPrePro Precio producto
     * @param mObjProducto Producto
     * @return Producto obtenido de la creación
     * @throws InputException
     */
    public abstract LogN_ClassAb_LineaFac CrearLinFac (float mCan, float mDes, float mPrePro, LogN_ClassAb_Producto mObjProducto)throws InputException;

    public float getMontoPago() {
        float montoPago = 0;
        for (LogN_Inter_FormaPag ObjForP : mColForPag )
            montoPago += ObjForP.getMonto();
        return montoPago;
    }

    @Override
    public String getCodDoc() {
        return mSerFac + " " + mNum;
    }
    
    

}



